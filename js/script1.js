// Ex.1  
// Задача на повернення ініціалів для кожного імені з 
//масиву, посортованих в алфавітному порядку
// Рішення має працювати незалежно від 
//конкретних значень в масиві імен
// 
const userNames = [
	// Додаємо різних значень в завдання, головна умова - розділення пробілом.
	"Петрик Ольга Іванівна",
	"Петрик Ольга Іванівна",
	"Доценко Андрій Володимирович",
	"Доценко Андрій",
	"Рудко Андрій Опанасович",
	"Рудко Андрій Опанасович",
	"Д А В",
	"Д. А. В.",
	"Petryk Olha Ivanivna",
	"Petryk Olha Ivanivna",
	"Dotsenko Andrii Volodymyrovych",
	"Dotsenko Andrii",
	"Rudko Andrii Opanasovych",
	"Rudko Andrii Opanasovych",
	"D A V",
	"D. A. V.",
	"Dotsenko A. V.",
	"Hnatiuk Petro Antonovych",
	"Rudko Andrii Opanasovych",
	"Dotsenko Andrii Volodymyrovych",
	"Rudko Andrii Opanasovych",
	"Доценко А. В.",
	"R. A.",
	"Гнатюк Петро Антонович",
	"Рудко Андрій Опанасович",
	"Доценко Андрій Володимирович",
	"Рудко Андрій Опанасович",
]

let initials
//========================================================================================================================================================
console.log(userNames) //Вхідні дані
// Проходимо по userNames методом map, по кожному значенню:
initials = userNames.map((name) => {

	// Кожне значення масиву (строку) перетворюємо на масив userName,
	// розділивши пробілом за допомогою split,
	// отримуємо масив типу ['Прізвище', 'Ім'я', 'По.б..'] :
	const userName = name.split(' ')

	// Проходимся ще раз методом map, 
	// але вже по конкретній "особі" (array userName).
	// map повертає першу літеру для кожної частини імені 
	// Результати складаємо в масив initials

	const initials = userName.map((part) => part[0])
	// Збираємо всі ініціали в рядки за допомогою метода join
	// (збирає елементи масива initials в рядок, розділивши заданим "."
	// Оскільки join не ставить крапку після останнього елемента,
	// додаємо в кінець крапку конкатинацією з рядком "."
	return initials.join('.') + '.'
})
// Сортуємо масив ініціалів методом sort без переданої функції (за  "алфавітним" порядком)
initials.sort()

// Виводимо результат в консоль
console.log(initials)

// ['D.A.', 'D.A.V.', 'D.A.V.', 'D.A.V.', 'D.A.V.', 'D.A.V.', 'H.P.A.', 'P.O.I.', 'P.O.I.',
// 'R.A.', 'R.A.O.', 'R.A.O.', 'R.A.O.', 'R.A.O.', 'Г.П.А.', 'Д.А.', 'Д.А.В.', 'Д.А.В.',
// 'Д.А.В.', 'Д.А.В.', 'Д.А.В.', 'П.О.І.', 'П.О.І.', 'Р.А.О.', 'Р.А.О.', 'Р.А.О.', 'Р.А.О.']
//========================================================================================================================================================

// 2. Задача на фільтрування масиву
// Реалізуйте фільтрування імен які починаються з голосної двома способами:

//1.1. через умовну конструкцію

//========================================================================================================================================================
// Я перейменував назву перемінної масиву, для тогощоб все працювало в одному файлі одразу
const userFirstNames = ['Петро', 'емма', 'Юстин',
	'Ілля', 'Марта', 'Яна', 'Василь', 'Антон', 'Олена',
	'John', 'Adam', 'Petro', 'Emma', 'Iustyn', 'Illia',
	'Marta', 'Iana', 'Vasyl'];
let filteredNames;




//========================================================================================================================================================
// Масив з голосними літерами УКР + АНГЛ у нижньому регістрі для перевірки
lowels = ["a", "e", "i", "o", "u", "y", "а", "е", "є", "и", "і", "ї", "о", "у", "ю", "я",]

// Фільтруємо масив: проходимось по кожному значенню userFirstName масива userFirstNames
filteredNames = userFirstNames.filter((userFirstName) => {
	// Повертає true якщо в масиві lowels є перша літера userFirstName
	// до першої літери звертаємось за індексом 0 з методом (функцією) рядка toLowerCase() для отримання нижнього регістру
	// Якщо true - то filter заносить наш userFirstName до масиву filteredNames, якщо false продовжуэ перебирати
	return lowels.includes(userFirstName[0].toLowerCase())
})
// Виводимо результат в консоль
console.log(filteredNames);


//========================================================================================================================================================
filteredNames = [] // Обнуляємо масив після попереднього рішення
//========================================================================================================================================================

//2.2. через вбудований метод масивів Рішення має працювати незалежно від конкретних значень в масиві імен:

//========================================================================================================================================================
// Проходимо по кожноу елементу userName масива userFirstNames методом forEach
userFirstNames.forEach(userName => {
	let letter = userName[0].toLowerCase() // створюємо змінну = першій літері елемента в нижньому регістрі
	if ( // Якщо
		letter === "a" //Умова 1 ENG
		|| letter === "e" //або Умова 2 ENG
		|| letter === "i" //або Умова 3 ENG
		|| letter === "o" //або Умова 4 ENG
		|| letter === "u" //або Умова 5 ENG
		|| letter === "y" //або Умова 6 ENG

		|| letter === "а" //або Умова 7 UA
		|| letter === "е" //або Умова 8 UA
		|| letter === "є" //або Умова 9 UA
		|| letter === "и" //або Умова 0 UA
		|| letter === "і" //або Умова 10 UA
		|| letter === "ї" //або Умова 11 UA
		|| letter === "о" //або Умова 12 UA
		|| letter === "у" //або Умова 13 UA
		|| letter === "ю" //або Умова 14 UA
		|| letter === "я" //або Умова 15 UA
	) {
		filteredNames.push(userName) // додаємо в кінець масива filteredNames
	}
})
// Виводимо результат в консоль
console.log(filteredNames);
//========================================================================================================================================================




// 3. Задача на розворот числа:
const currentMaxValue = 4589;
let reverseMaxValue;
//========================================================================================================================================================

// переводимо currentMaxValue в рядок методом .toString() -> 
// розділяємо отриману строку в масив методом .split('') з аргументом пуста строка ->
// розвертаємо отриманий масив методом .reverse() ->
// з'єднуємо елементи отриманого масива в рядок (через "" - пустий рядок) методом .join('')
// переводимо отриману строку в число унарним + при присвоєнні змінній.
reverseMaxValue = +(currentMaxValue.toString().split('').reverse().join(''));
//========================================================================================================================================================
// Виводимо результат в консоль
console.log(reverseMaxValue); // 9854
console.log(typeof reverseMaxValue); // 'number'
//========================================================================================================================================================




// 4. Задача на знаходження добутку масиву чисел з невідомою глибиною вкладеності:
const resultsArray = [1, [[[[[[2], [3]]]]]], [4, [1]]];
let productOfArray;
//========================================================================================================================================================

// "Дістаємо" всі елементи з усіх вкладеностей в масив методом .flat(Infinity) 
// (де Infinity - параметр, який дістає всі вкладеності до нескінченності)
// Множимо елементи отриманого масива між собой за допомогою метода .reduce, 
// котрий перемножує по черзі всі елементи, при старті accum = першому елементу нашого масива.
productOfArray = resultsArray.flat(Infinity).reduce((accum, currVal) => accum * currVal)
// Виводимо результат в консоль
console.log(productOfArray); // 24
